<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>琅嬛福地</title>
  
  <subtitle>一个藏着武功秘籍的地方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heweijie.xyz/"/>
  <updated>2019-09-25T15:41:02.038Z</updated>
  <id>http://heweijie.xyz/</id>
  
  <author>
    <name>何炜杰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】 为什么python这么慢</title>
    <link href="http://heweijie.xyz/2019/09/24/%E3%80%90%E8%AF%91%E3%80%91-%E4%B8%BA%E4%BB%80%E4%B9%88python%E8%BF%99%E4%B9%88%E6%85%A2/"/>
    <id>http://heweijie.xyz/2019/09/24/【译】-为什么python这么慢/</id>
    <published>2019-09-23T16:07:51.000Z</published>
    <updated>2019-09-25T15:41:02.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python如今非常流行，它被广泛用于DevOps，数据科学，web开发以及安全等方面。</p><p>尽管如此，Python并没有在运行速度方面获得过任何的赞誉。</p><blockquote><p>与c ， c++ ， c# 或 python相比，java的运行速度如何呢？ 这个问题的答案取决于你在运行什么类型的程序。没有哪一个用于比较速度的基准是完美的，但使用编程语言基准游戏（<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/" target="_blank" rel="noopener">The Computer Language Benchmarks Game</a>）是一个不错的开始。<br>我参考了近十年来编程语言基准游戏的结果，发现与其他编程语言相比，Python是最慢的之一。这些编程语言包括了即时编译型语言（C#, Java)，提前编译型语言（C, C++）和JavaScript这种解释型语言。</p></blockquote><a id="more"></a> <p><em>注：当我说 “python” 时, 我说的是它语言的参考实现——CPython。在本文中，我还将提到它其他的参考实现。</em></p><p>我想回答这个问题：“Python执行一个程序比其他编程语言慢2-10倍，为什么它这么慢？我们就不能让它快点吗？”</p><p>以下是一些常见的论调：</p><ul><li>“是因为全局解释器锁（GIL，Global Interpreter Lock）。”</li><li>“因为它是一种解释型语言，并没有编译。”</li><li>“因为它是一种动态类型的语言。”</li></ul><p>那么哪一个原因才是对它的性能产生最大影响的呢？</p><h2 id="“因为全局解释器锁”"><a href="#“因为全局解释器锁”" class="headerlink" title="“因为全局解释器锁”"></a>“因为全局解释器锁”</h2><p>如果你以前没有从事过多线程编程，那么有一个概念你需要尽快熟悉——锁。与单线程编程不同，你需要确保当改变内存中的变量时，多个线程不会在同一时间访问或更改同一个内存地址。</p><p>当CPython创建一个变量的时候，它会分配内存地址，然后计算有多少个指向这个变量的引用存在，这是一种被称作“引用计数”的技术。当被引用的数量是0时，这个变量就会从内存中释放。这也就是为什么你在循环体内创建一个”临时“变量的时候，并不会让你的应用程序的内存消耗猛增。</p><p>所以挑战就变成了当多个线程共享一个变量的时候，CPython是如何锁定引用计数的？有一个全局解释器锁仔细地控制着线程的执行，这个解释器每一次只能执行一个操作，而不管有多少个线程。</p><h3 id="对于Python应用程序来说，这意味着什么？"><a href="#对于Python应用程序来说，这意味着什么？" class="headerlink" title="对于Python应用程序来说，这意味着什么？"></a>对于Python应用程序来说，这意味着什么？</h3><p>如果你的程序是单线程的，单解释器的，那对你的速度并没有任何差别。移除GIL对你的程序的性能也没有任何影响。</p><p>如果你想用多线程在一个解释器中实现并发性，并且你的线程是IO密集的（例如，网络IO或磁盘IO），你就会看到GIL竞争资源的后果。</p><p><img src="/images/GIL%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A.png" alt="GIL可视化"></p><pre><code>[出自David Beazley的GIL可视化报告](http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html)</code></pre><p>如果你的程序是一个网络应用程序（例如，使用了Django），并且你用了WSGI，那么每个给你的网络应用程序发送的请求都是一个单独的Python解释器，所以每个请求都有一个锁。因为Python解释器启动很慢，因此某些 WSGI的实现具有 “守护进程模式”，它能保持Python进程启动着，并且随时待命。</p><h3 id="Python其他的具体实现怎么样？"><a href="#Python其他的具体实现怎么样？" class="headerlink" title="Python其他的具体实现怎么样？"></a>Python其他的具体实现怎么样？</h3><p><a href="http://doc.pypy.org/en/latest/faq.html#does-pypy-have-a-gil-why" target="_blank" rel="noopener">PyPy也有GIL</a>，但它比 CPython 快了3倍以上。</p><p><a href="http://www.jython.org/jythonbook/en/1.0/Concurrency.html#no-global-interpreter-lock" target="_blank" rel="noopener">Jython没有GIL</a>，因为在 Jython 中的 Python线程由 Java线程表示, 并受益于 JVM的内存管理系统，使得它并不需要GIL。</p><h3 id="JavaScript-是怎么做的呢？"><a href="#JavaScript-是怎么做的呢？" class="headerlink" title="JavaScript 是怎么做的呢？"></a>JavaScript 是怎么做的呢？</h3><p>首先，所有的JavaScript 引擎都使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">标记和扫描垃圾回收机制</a>，而正如我们上面提到的那样，需要GIL的最重要原因是CPython那样的内存管理算法。</p><p>JavaScript 没有GIL，但因为它是单线程的，所以不需要GIL。JavaScript 的事件循环和Promise/Callback模式是用异步编程替代了并发性。在Python中，使用 asyncio 模块中的事件循环也能做到类似的事情。</p><h2 id="“因为它是一门解释型语言”"><a href="#“因为它是一门解释型语言”" class="headerlink" title="“因为它是一门解释型语言”"></a>“因为它是一门解释型语言”</h2><p>我常常听别人这样说，但我觉得这是对CPython真正的工作方式的一种草率的简化。当你在你的终端写下myscript.py文件，CPython会进行以下一系列的工作：读取、词法分析、语法分析、编译、解释，然后运行这些代码。</p><p>如果你对这个过程感兴趣，可以参考我之前写的一篇文章<a href="https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14" target="_blank" rel="noopener">《6分钟内改造Python语言》</a>。</p><p>一个关键点就是这个过程中会产生一个.pyc文件。在编译阶段，字节码会被写入到_<em>pycache_</em>/的下的一个文件中。不仅仅是自己写的脚本会这样，所有你导入的代码（包括第三方库），都会这样。</p><p>所以大多数情况下（除非你写了代码只运行一次？），Python会解释这些字节码，并在本地执行它。我们不妨将其与Java 和 C#.NET进行比较：</p><blockquote><p>Java 会被编译为“中间语言”。Java虚拟机读取字节码并将其<strong>及时</strong>编译为机器码。.NET CIL也是如此。</p></blockquote><pre><code>他们都采用了虚拟机和类似的字节码，为什么Python在基准测试中会比ava 和 C#慢得多呢？首先，Java 和 C#都是及时编译的。</code></pre><p>及时编译需要一种中间语言，使得代码能被分为块（或帧）。而提前编译的语言被设计成这样：在任何交互发生前，确保CPU能读懂每段代码。</p><p>及时编译本身并不能使运行速度变得更快，因为它执行的仍然是相同的字节码序列。但是即时编译使得运行时的优化成为可能。一个好的即时编译优化器会查看这个应用程序的哪一部分代码经常被执行，并将这部分称为“热点”。然后会对这部分代码做出优化，把他们替换为更有效率的版本。</p><p>这意味着当你的应用程序一遍又一遍地重复同样的事情的时候，它的速度将会明显地提升。同时，记住Java 和 C#都是强类型的语言，所以优化器能对代码做出更多的假设。</p><p><strong>PyPy是及时编译的</strong>，它也比CPython快的多。<a href="https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b" target="_blank" rel="noopener">这篇性能基准测试的文章</a>提供了更多的细节。</p><h3 id="为什么CPython不采用即时编译技术呢？"><a href="#为什么CPython不采用即时编译技术呢？" class="headerlink" title="为什么CPython不采用即时编译技术呢？"></a>为什么CPython不采用即时编译技术呢？</h3><p>及时编译有一些缺点，其中一个就是启动时间太慢。CPython的启动时间相对来说已经挺慢的了，PyPy比它还要慢2~3倍。而Java虚拟机启动速度慢更是臭名昭著。</p><p>如果你有一个Python程序需要运行很长时间，那么由于“热点”的存在，代码能够被优化。这种情况下，即时编译意义非凡。</p><p>但是CPython是多用途的。如果你用Python开发命令行工具，你每在命令行中输入一条命令就要等即时编译器启动，那是相当慢的。</p><p>所以如果你想享受及时编译带来的好处，并且有适合的工作，那就用PyPy吧。</p><h2 id="“因为它是动态类型的语言”"><a href="#“因为它是动态类型的语言”" class="headerlink" title="“因为它是动态类型的语言”"></a>“因为它是动态类型的语言”</h2><p>在静态类型的语言中，你在声明一个变量的时候，必须指定它的变量类型。这样的语言包括C, C++, Java, C#, Go。</p><p>而在动态类型的语言中，仍然有变量类型的概念，但变量的类型是可以改变的。</p><p>静态类型的语言不是为了让你的生活更加艰难才这样设计的，这样设计是因为CPU的工作方式。如果所有东西最终都将等同于简单的二进制操作，你不得不将对象和类型转化为底层的数据结构。</p><p>Python也为了做了这样的事，只不过你从没见过，或者你不需要操心这个。</p><p>不需要声明类型并不会使Python变慢。Python的语言设计使得你可以将几乎所有的东西都变成动态的。你可以在运行时替换对象中的方法。</p><p>正是这样的设计使得优化Python变得<strong>异常艰难</strong>。</p><p>为了阐明我的观点，我使用了一款名为Dtrace的系统调用追踪工具来追踪Python程序的执行过程。有如下发现：</p><ul><li><p>比较和转换类型的成本很高, 每次读取、写入或引用变量时, 都需要检查类型。</p></li><li><p>很难优化如此动态的语言。python 的许多替代方案之所以快得多, 是因为它们为了性能，而对灵活性做出了妥协。</p></li><li><p>看看<a href="http://cython.org/" target="_blank" rel="noopener">cython</a>, 它将 c-静态类型和 python结合了起来, 以优化那些已知变量类型的代码，可以使得性能有84倍的提升。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python慢的主要原因是它动态的天性和它的多功能性。它可以作为解决各种问题的工具, 但这些问题可能有更优化和更快的解决方案。</p><p>但是, 还有一些方法可以优化 python 应用程序，例如：利用异步、理解性能分析工具和使用多解释器。</p><p>对于那些启动时间不重要且代码能从即时编译中获利的应用程序, 请考虑使用PyPy。</p><p>对于代码中性能非常关键且具有很多静态类型变量的部分, 请考虑使用Cython。</p><hr><p>原文：</p><p>Anthony Shaw <a href="https://hackernoon.com/why-is-python-so-slow-e5074b6fe55b?hmsr=pycourses.com" target="_blank" rel="noopener">Why is Python so slow?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Python如今非常流行，它被广泛用于DevOps，数据科学，web开发以及安全等方面。&lt;/p&gt;
&lt;p&gt;尽管如此，Python并没有在运行速度方面获得过任何的赞誉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与c ， c++ ， c# 或 python相比，java的运行速度如何呢？ 这个问题的答案取决于你在运行什么类型的程序。没有哪一个用于比较速度的基准是完美的，但使用编程语言基准游戏（&lt;a href=&quot;https://benchmarksgame-team.pages.debian.net/benchmarksgame/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Computer Language Benchmarks Game&lt;/a&gt;）是一个不错的开始。&lt;br&gt;我参考了近十年来编程语言基准游戏的结果，发现与其他编程语言相比，Python是最慢的之一。这些编程语言包括了即时编译型语言（C#, Java)，提前编译型语言（C, C++）和JavaScript这种解释型语言。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://heweijie.xyz/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="python" scheme="http://heweijie.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【译】 十年内教会自己编程</title>
    <link href="http://heweijie.xyz/2019/09/22/%E5%8D%81%E5%B9%B4%E5%86%85%E6%95%99%E4%BC%9A%E8%87%AA%E5%B7%B1%E7%BC%96%E7%A8%8B%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/"/>
    <id>http://heweijie.xyz/2019/09/22/十年内教会自己编程（翻译）/</id>
    <published>2019-09-22T04:07:09.549Z</published>
    <updated>2019-09-25T15:34:51.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-KLeLvInM" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="3986040" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><h3 id="为什么大家都这么浮躁？"><a href="#为什么大家都这么浮躁？" class="headerlink" title="为什么大家都这么浮躁？"></a>为什么大家都这么浮躁？</h3><p>走进书店，你就能看到一本《24小时自学Java》的书，与它摆在一起的，还有许许多多短时间内学会C，SQL，Ruby或算法的书。我在亚马逊上，做了这样的高级搜索 “书名：自学 小时  ”，发现2000年后出版的这样的书就有512本！这其中，销量前10的书中有9本是关于编程的（还有一本是关于记账的）。</p><p>所以我们可以得出结论：要么人们学编程时太浮躁了，要么编程实在太容易了，比其他任何技能都要容易学会。Felleisen在他的著作<a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html" target="_blank" rel="noopener">《如何设计程序》</a>中提到了这种“速成”的趋势，并且指出：“糟糕的编程当然很容易学会，白痴也能在21天内学会，哪怕他们天生有智力缺陷。”</p><a id="more"></a> <h3 id="十年内教会自己编程"><a href="#十年内教会自己编程" class="headerlink" title="十年内教会自己编程"></a>十年内教会自己编程</h3><p>研究人员（(<a href="http://www.amazon.com/exec/obidos/ASIN/034531509X/" target="_blank" rel="noopener">Bloom (1985)</a>, <a href="http://norvig.com/21-days.html#bh" target="_blank" rel="noopener">Bryan &amp; Harter (1899)</a>, <a href="http://www.amazon.com/exec/obidos/ASIN/0805803092" target="_blank" rel="noopener">Hayes (1989)</a>, <a href="http://norvig.com/21-days.html#sc" target="_blank" rel="noopener">Simmon &amp; Chase (1973)</a>）发现，在很多领域内，如果你想获得专家级别的水平，大概需要十年的时间。这些领域包括了下象棋、作曲、绘画、弹钢琴、游泳、打网球、对神经心理学和拓扑学的研究等等。这其中的关键是<strong><em>刻意</em></strong>练习：并不是一遍又一遍的重复，而是给自己设定一个稍微超过自己当前能力的目标，尝试着去完成它。在尝试的过程中以及尝试结束后，分析自己的表现，并纠正自己的错误。然后再把这个过程不断的重复。所谓的“捷径”是不存在的：即使是莫扎特这种4岁就能作曲的音乐奇才，也花了13年时间，才能创作出世界级的作品。</p><p><a href="http://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922" target="_blank" rel="noopener">Malcolm Gladwell</a> 使得这个观点广为人知，尽管他关注的重点是1万小时，而不是10年。Samuel Johnson 也说过：“在任何一个领域要想做到极致,势必要花一生的精力，否则根本无法企及。” </p><p>当然，没有哪个数字能给你最终答案：假设熟练掌握每个技能（例如编程、下棋、演奏）所需的时间相同，或者假设每个人学会这些技能的时间相同，这完全是不合理的。正如 <a href="http://www.amazon.com/K.-Anders-Ericsson/e/B000APB8AQ/ref=dp_byline_cont_book_1" target="_blank" rel="noopener">K. Anders Ericsson</a> 指出的那样：“在很多领域，即使是那些最有天赋的个人，为了达到最高水平，也花费了难以想象的时间。1万小时这个数字只是想让你意识到即便是人们口中的那些最具天赋的个体想达到最高水平也需要年复一年的每周花上 10 到 20 小时。”</p><h3 id="你真的想当程序员吗？"><a href="#你真的想当程序员吗？" class="headerlink" title="你真的想当程序员吗？"></a>你真的想当程序员吗？</h3><p>我有一份成功学会编程的秘诀：</p><ul><li>对编程<strong>感兴趣</strong>，并且因为有趣而去编写一些程序。只有保证它足够有趣，这样你才愿意投入10年或是1万小时。</li><li><strong>写程序</strong>。最好的学习方法是从实践中学习。用更专业一点的话来说：“某个人在特定领域内的最高水平，不是因为经验的积累而自动获得的。即使是经验非常丰富的人，也可以通过刻意练习来提高自己的水平。”(p. 366)以及“最有效的学习方式，需要一个明确定义的目标，而且这个目标要有一定的难度；需要及时的信息反馈；需要有机会重来和纠正错误。”(p. 20-21)<a href="http://www.amazon.com/exec/obidos/ASIN/0521357349" target="_blank" rel="noopener">《实践中的认知:日常生活中的思维、数学和文化》</a>这本书提供了上述的观点。</li><li>和其他程序员<strong>交流</strong>；阅读他们的代码。这比任何一本书或者训练课程都重要。</li><li>如果你愿意，花四年上个<strong>大学</strong>（或者更久，读个研究生）。这会让你有机会得到一份需要文凭的工作。而且这也会让你对这个领域有更深层次的理解。但如果你不想呆在学校，你也可以通过自学或工作获得类似的经验（但需要付出一定代价）。无论如何，仅仅学习书本上的知识是不够的。《新黑客字典》的作者Eric Raymond曾说过：“计算机科学教育并不能使任何人成为编程专家，就像学习笔刷和颜料并不能使得任何人成为一个专业画家。”我曾经雇佣过一个员工，只有高中文凭，却是我们最好的程序员之一。他做出了许多<a href="http://www.xemacs.org/" target="_blank" rel="noopener">优秀的</a><a href="http://www.mozilla.org/" target="_blank" rel="noopener">软件</a>，有他自己的<a href="http://groups.google.com/groups?q=alt.fan.jwz&meta=site%3Dgroups" target="_blank" rel="noopener">新闻组</a>， 而且通过股票期权买到了自己的<a href="http://en.wikipedia.org/wiki/DNA_Lounge" target="_blank" rel="noopener">夜总会</a>。</li><li>与其他程序员一起<strong>合作</strong>。在一些项目中，你可能是最好的程序员；在另一些项目中，你可能是最差的程序员。当你是最好的程序员时候，你能测试下自己领导一个项目的能力，并能用自己的观点去激发别人。当你是最差的程序员时候，你可以学到那些牛人们是怎么做的，他们不喜欢做什么（因为他们会把不喜欢的事情丢给你去做）。</li><li><strong>接手</strong>别人的项目。理解别人所写的程序。看看当程序的原作者不在的时候，理解并改正他的程序需要花费什么。思考一下，如何设计程序，才能让其他人维护你的程序变得容易些。</li><li>学习至少6门<strong>编程语言</strong>。包括一门支持类抽象的语言（例如Java或C++）。一门支持函数化抽象的语言（例如 Lisp 或 ML 或 Haskell），一门支持语法抽象的语言（例如 Lisp），一门支持声明规格说明的语言（例如 Prolog 或 C++ 的模板），以及那些强调并行的语言（例如 Clojure 或 Go）。</li><li>记住在“计算机科学”中有<strong>“计算机”</strong>这三个字。你需要知道你的计算机执行一条指令会花费多长时间？从内存中读取一个单词（包括在缓存中和不在缓存中两种情况）会花费多长时间？从硬盘中连续地获取数据会花费多长时间？在硬盘上定位一个新的位置会花费多长时间？ (<a href="http://norvig.com/21-days.html#answers" target="_blank" rel="noopener">答案在这儿</a>)。</li><li>尽量参与到语言<strong>标准化</strong>的过程中。这可以是加入ANSI C++委员会；也可以是决定你周围人的编程风格：缩进采用2个空格还是4个空格？无论用哪种方式，你都能知道别人对于一门语言的看法和喜好程度，甚至你可以知道为什么他们会这样看。</li><li>有良好的意识，尽快<strong>适应</strong>编程语言标准化的成果。</li></ul><p>Fred Brooks 在他的论文《没有银弹》中向我们揭示了找到卓越软件设计师的三个步骤：</p><ol><li>有组织地鉴定出顶尖的设计者，并且越早越好。</li><li>为他指派一位职业生涯的导师，负责规划他未来的发展，并且让他谨慎地对待自己的职业履历。</li><li>为成长中的软件设计师提供机会，让他们相互交流，相互激励。</li></ol><p>这个方式假定了有些人已经具备了成为一个卓越的软件设计师的潜质，要做的只是去引导他们。<a href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html" target="_blank" rel="noopener">Alan Perlis</a> 说的更简洁一些：“每个人都能被教会如何雕塑，但米开朗琪罗应该被教会如何不去雕塑。对于优秀的程序员来说，同样如此。”Perlis 的意思是说，那些大师们都有一些内在的特质，这些特质比他们接受的训练更为重要。但是这些特质从哪里来呢？它是天生的吗？还是可以通过后天的努力习得的呢？正如《料理鼠王》中说的那样：“每个人都能做饭，但只有无所畏惧的人才能成为大厨。”我认为“把生命中大部分时光用于刻意练习”是心甘情愿的，但也许无所畏惧才是对它最好的总结。或者正如《料理鼠王》中说的那样：“不是每个人都能成为伟大的艺术家，但伟大的艺术家可以来自于任何一个地方。”</p><p>所以，尽管去买那些速成的编程书吧。也许你会发现它们还有点用，但这不会改变你的人生。也不会让你在24小时或21天内，在编程领域上，有真正的整体上的提高。试试连续24个月努力提高自己的编程能力怎么样？如果你做到的话，你已经开始迈向成功之路了……</p><hr><p><em>注：由于时间原因，没有一字一句翻译。省略了部分我认为不重要的内容。</em><br>原文：</p><p>Peter Norvig <a href="http://norvig.com/21-days.html" target="_blank" rel="noopener">  “Teach Yourself Programming in Ten Years ”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-KLeLvInM&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;3986040&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#555&quot;&gt;&lt;/div&gt;

&lt;h3 id=&quot;为什么大家都这么浮躁？&quot;&gt;&lt;a href=&quot;#为什么大家都这么浮躁？&quot; class=&quot;headerlink&quot; title=&quot;为什么大家都这么浮躁？&quot;&gt;&lt;/a&gt;为什么大家都这么浮躁？&lt;/h3&gt;&lt;p&gt;走进书店，你就能看到一本《24小时自学Java》的书，与它摆在一起的，还有许许多多短时间内学会C，SQL，Ruby或算法的书。我在亚马逊上，做了这样的高级搜索 “书名：自学 小时  ”，发现2000年后出版的这样的书就有512本！这其中，销量前10的书中有9本是关于编程的（还有一本是关于记账的）。&lt;/p&gt;
&lt;p&gt;所以我们可以得出结论：要么人们学编程时太浮躁了，要么编程实在太容易了，比其他任何技能都要容易学会。Felleisen在他的著作&lt;a href=&quot;http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《如何设计程序》&lt;/a&gt;中提到了这种“速成”的趋势，并且指出：“糟糕的编程当然很容易学会，白痴也能在21天内学会，哪怕他们天生有智力缺陷。”&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://heweijie.xyz/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="学习方法" scheme="http://heweijie.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
